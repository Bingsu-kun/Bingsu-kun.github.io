<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HEPHAI's devlog</title>
    <description>Mainly about coding, also my hobbys.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 29 Mar 2021 18:05:14 +0900</pubDate>
    <lastBuildDate>Mon, 29 Mar 2021 18:05:14 +0900</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Jenkins 사용 정리</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;jenkins-개념-설치-및-실행-정리&quot;&gt;Jenkins 개념, 설치 및 실행 정리&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;jenkins-란&quot;&gt;Jenkins 란?&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;소프트웨어 개발 시 지속적으로 통합서비스를 제공해주는, CI(Continuous Integration)툴 이다.&lt;/p&gt;

&lt;p&gt;Git과 같은 버전관리시스템과 연동하여 커밋을 감지하면 자동빌드/배포 되도록 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 커밋은 매우 빈번히 일어나기 때문에 작업이 큐잉되어 빌드되는 것이 일반적이다.&lt;/p&gt;

&lt;p&gt;이러한 자동화 작업은 다음과 같은 이점이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로젝트 표준 컴파일 환경에서의 컴파일 오류 검출&lt;/li&gt;
  &lt;li&gt;자동화 테스트 수행&lt;/li&gt;
  &lt;li&gt;정적 코드 분석에 의한 코딩 규약 준수여부 확인&lt;/li&gt;
  &lt;li&gt;프로파일링 툴을 이용한 성능 변화 모니터링&lt;/li&gt;
  &lt;li&gt;결합 테스트 환경에 대한 배포작업&lt;/li&gt;
  &lt;li&gt;각종 배치 작업의 간략화&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jenkins는 또한 플러그인을 간단히 인스톨 할 수 있는 기능을 제공하고 있어 자신에게 필요한 기능을 손쉽게 사용가능하다. 혹여나 기능이 없다면 파이썬과 같은 스크립트를 이용해 추가 할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;jenkins-설치&quot;&gt;Jenkins 설치&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;jenkins는 yum 명령어로 설치되지 않는다. 그래서 다음 명령들을 실행해야한다.&lt;/p&gt;

&lt;p&gt;OS 환경은 CentOS7 이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
sudo tpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그다음 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo yum install jenkins&lt;/code&gt; 명령을 치면 설치가 잘 된다.&lt;/p&gt;

&lt;p&gt;설치 후에는 잊지말고 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl start jenkins&lt;/code&gt;로 daemon을 실행시켜주자.&lt;/p&gt;

&lt;p&gt;또는 DockerHub에서 이미지를 다운받아 Docker로 실행하는 방법도 있다. 이에 대한 설명은 생략한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;jenkins-실행&quot;&gt;Jenkins 실행&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;jenkins는 기본으로 8080포트를 사용한다. 클라우드 환경이라면 외부 IP:8080, 로컬이라면 localhost:8080 으로 접속하면 비밀번호를 입력하라는 창이 나온다.&lt;/p&gt;

&lt;p&gt;창에 나와있는 경로로 가면 비밀번호가 있으니 복붙해서 접속하면 플러그인 설치가이드가 나온다.&lt;/p&gt;

&lt;p&gt;왼쪽은 일반설치, 오른쪽은 매뉴얼 설치인데 만약 설치 중 계속 installation fail이 뜨고 그냥 넘어가거나 재시도 해야하는 상황이 되었다면 &lt;strong&gt;버전&lt;/strong&gt;문제이므로 최신 버전을 설치해주자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;설치가 완료 후 jenkins가 안전하게 worker instance에 접속할 수 있도록, 그리고 다른 접속을 막기위해 ssh-key-pair를 이용해 비대칭키를 만들어 적용한다.&lt;/p&gt;

&lt;p&gt;우선 jenkins server terminal에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-keygen -t rsa -f ~/.ssh/id_rsa&lt;/code&gt; 명령어로 키페어를 만들어준다.&lt;/p&gt;

&lt;p&gt;그 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;.ssh&lt;/code&gt; 디렉토리로 들어가보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;.pub&lt;/code&gt;이 있는 것과 없는 것 두 가지가 있을텐데 &lt;code class=&quot;highlighter-rouge&quot;&gt;.pub&lt;/code&gt;이 있는 것을 복사해서 worker instance의 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/authorized_keys&lt;/code&gt; 파일에 붙여넣기 해준다.&lt;/p&gt;

&lt;p&gt;그 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;/.ssh&lt;/code&gt; 디렉토리의 권한은 700으로, &lt;code class=&quot;highlighter-rouge&quot;&gt;/.ssh/authorized_keys&lt;/code&gt;는 600으로 바꿔준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;클라우드 환경인 경우, 클라우드 제공자가 ssh 키를 따로 보관하는 경우가 있으니 참고&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;배포하기&quot;&gt;배포하기&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 jenkins 관리 페이지로 가서 Publish over SSH 플러그인을 설치 해준 후, 환경설정에서 맨아래 Publish over SSH의 Key 칸에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.pub&lt;/code&gt;이 없었던 개인키를 복붙해주고 ssh servers에 Name은 임의로, Hostname은 worker instance의 주소, Username은 worker instance에서 사용하는 user 이름, Remote Directory는 웬만하면 home 디렉토리로 설정해서 저장.&lt;/p&gt;

&lt;p&gt;다시 메인으로 가서 새로운 아이템 만들기, 프리스타일 프로젝트, 맨 아래 ‘빌드 후 조치’.&lt;/p&gt;

&lt;p&gt;‘고급’ 클릭 후 verbose output in console을 체크, 그 다음 Exec command에 컨테이너 실행명령을 적어주자.&lt;/p&gt;

&lt;p&gt;다음, 메인화면에서 Build Now를 누르면 빌드가 시작된다. 빌드가 완료되면 왼쪽아래에 무엇인가 떴을 것이다. #1 같이 뜬 것의 이름 옆 삼각형을 눌러 Console Output을 볼 수 있는데 이것을 보며 TroubleShooting 하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;만약 스프링 같은 웹서버를 구동할 경우 정상 작동 중인데 빌드가 완료되지 않았다고 표시가 된다. 그럴 땐 다시 구성으로 가서 Exec command의 코드를&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nohup ... &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;로 수정하고 다시 실행 해보자. &lt;code class=&quot;highlighter-rouge&quot;&gt;nohup&lt;/code&gt;과 맨 뒤 &amp;amp;는 이 명령을 백그라운드로 실행시키겠다는 뜻이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt;명령은 표준에러를 표준출력으로 리다이렉트 시켜준다는 명령이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;또한 도커로 컨테이너를 실행한다면 /var/run/docker.sock 관련 권한 오류가 나오는데, 이는 worker instance로 가서 &lt;code class=&quot;highlighter-rouge&quot;&gt;chmod 666 /var/run/docker.sock&lt;/code&gt; 명령어를 실행시키면 해결된다.&lt;/p&gt;

</description>
        <pubDate>Mon, 29 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2021/03/29/Jenkins/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/29/Jenkins/</guid>
        
        
        <category>Back-End-Study</category>
        
      </item>
    
      <item>
        <title>GCP 이용 중 yum install error</title>
        <description>&lt;h3 id=&quot;issue&quot;&gt;Issue&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Google Cloud Platform에서 Compute Engine 서비스로 CentOS 7 이용 중 yum install error가 발생하여 설치가 안되는 상황.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/danhdvla9/image/upload/v1616996607/ScreenShots/21-03-29/1_bqgqeu.png&quot; alt=&quot;error&quot; /&gt;
&lt;strong&gt;yum signature could not be verified&lt;/strong&gt;로 통칭되는 오류이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;steps-to-reproduce-the-issue&quot;&gt;Steps to reproduce the issue&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그저 GCP나 AWS Instance를 LinuxOS로 생성하고 yum, apt 등의 패키지 매니저를 통해 install 하려하면 등장한다.&lt;/p&gt;

&lt;p&gt;stackoverflow에서 같은 오류를 겪은 사람이 어떻게 해결했나 보러 다녔는데, 항상 발생하는 것은 아니고 가끔씩 gpg key에 의해 발생하는 오류로 추정된다고 하더라.&lt;/p&gt;

&lt;p&gt;GCP나 AWS Linux를 이용하다보면 드물게 발생한다는데…. 
&lt;del&gt;이런건 왜 나만 걸리는 걸까&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;troubleshooting&quot;&gt;TroubleShooting&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;처음 접근은 에러메세지에서 추천하는 방법 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;--disablerepo&lt;/code&gt; 옵션을 사용한 방법을 실행하였지만 같은 오류의 반복이었다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;이 부분에서 에러메세지를 자세히 보지 않고 간과한 것이 빙 돌아가는 길의 시작이었다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;두번째로 gpg key를 몽땅 갈아엎고 새로 업데이트 시키자고 생각하여&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm --import &amp;lt;(curl -s -L https://packages.cloud.google.com/yum/doc/yum-key.gpg)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;명령으로 새로운 키를 받아와보려했으나 write body failed가 뜨면서 어려워졌다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다시 오류메세지를 제대로 읽어보자고 생각, &lt;code class=&quot;highlighter-rouge&quot;&gt;--disablerepo=google-cloud-sdk&lt;/code&gt; 옵션을 이용하여 에러메세지를 띄우고 보았더니 &lt;code class=&quot;highlighter-rouge&quot;&gt;google-compute-engine&lt;/code&gt; 이라는 레포지토리가 하나 더 걸려서 에러가 지속되었던 것.&lt;/p&gt;

&lt;p&gt;최종적으로&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo yum install wget --disablerepo=google-cloud-sdk,google-compute-engine -y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;처럼 걸리는 레포지토리들을 전부 &lt;code class=&quot;highlighter-rouge&quot;&gt;--disablerepo&lt;/code&gt; 옵션으로 걸러내주니 정상 작동하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/danhdvla9/image/upload/v1616996607/ScreenShots/21-03-29/2_nxe0jc.png&quot; alt=&quot;complete&quot; /&gt;
&lt;em&gt;예에~&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;하지만 명령마다 저 옵션을 써주기엔 너무 번거로워서 조금 더 시간을 내어 완벽하게 오류를 고쳐보려했으나&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/danhdvla9/image/upload/v1616996607/ScreenShots/21-03-29/3_udzgxq.png&quot; alt=&quot;find error&quot; /&gt;
&lt;em&gt;(처절한 에러와의 싸움.png)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;고쳐지는건 나였고, 구글의 프로그래머 분들에게 떠넘기기로 했다. &lt;del&gt;헤헤&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;추가&quot;&gt;추가&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;글을 적으면서 문득 떠오른것이, ‘어 그럼 gpg 키 검사 안하면 되는거 아닌가?’&lt;/p&gt;

&lt;p&gt;그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;--nogpgcheck&lt;/code&gt; 옵션으로 해봤더니 또 잘된다.&lt;/p&gt;

&lt;p&gt;gpg key는 무엇이고 왜 없어도 잘 동작되는지 궁금해지기 시작했다.&lt;/p&gt;

</description>
        <pubDate>Mon, 29 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2021/03/29/GCP-%EC%9D%B4%EC%9A%A9-%EC%A4%91-yum-install-error/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/29/GCP-%EC%9D%B4%EC%9A%A9-%EC%A4%91-yum-install-error/</guid>
        
        
        <category>TroubleShooting</category>
        
      </item>
    
      <item>
        <title>SCOFE2021 Review</title>
        <description>&lt;h2 id=&quot;21년-3월-23일-스코페-2021-리뷰&quot;&gt;21년 3월 23일 스코페 2021 리뷰&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;--나에게-대회-란&quot;&gt;- 나에게 “대회” 란&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;대학생 때의 나는 대회에 대해,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;“입상의 가능성이 있을 때 나가는 것.”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이라는 생각을 가지고 있었다.&lt;/p&gt;

&lt;p&gt;항상 준비가 어느정도 되야 나가는 의미가 있다고 생각했다.&lt;/p&gt;

&lt;p&gt;지금 생각하면 너무 아쉽고 왜 그렇게 생각하고 있었을까 하는 후회가 든다.&lt;/p&gt;

&lt;p&gt;나도 믿기지 않는 사실이, 그동안 IT와 관련된 공모전, 대회, 콘테스트, 페스티벌 같은 활동에 관심도 없었고 참여도 하지 않았다는 것이다.&lt;/p&gt;

&lt;p&gt;어쩌면 그때의 나는 전공이 컴공임에도 불구하고 코딩에 흥미를 못느끼고 있었던 것일지도 모른다.&lt;/p&gt;

&lt;p&gt;하지만 이번 스코페를 통해 인식이 바뀌었다.&lt;/p&gt;

&lt;p&gt;그동안 참가에 의의를 두고 출전해서 뿌듯함을 느낀 것으론 축구, 게임 밖에 없었는데 코딩에서도 그것을 느끼니 굉장히 오묘한, 끝난 후에도 아드레날린이 솟구치는 느낌이랄까.&lt;/p&gt;

&lt;p&gt;새로운 시작을 열리는 경험이 되었다.&lt;/p&gt;

&lt;p&gt;그래서 이제는 대회에 대해&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;“새로운 분야에 발을 들이기 위한 엔진.”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이라고 표현하고 싶다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;--소감&quot;&gt;- 소감?&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;재밌었다. 내 상황이 준비되지 않았음에도 불구하고.&lt;/p&gt;

&lt;p&gt;대회를 마쳤음에도 마음에 불씨가 계속 피어올라 있었다.&lt;/p&gt;

&lt;p&gt;주력 언어인 Java를 두고 코딩테스트를 위해 Python을 쓰자라고 결정하고, 3일동안 코드업 기초 100제와 모의테스트 문제만 풀고 출전하게 되었다.&lt;/p&gt;

&lt;p&gt;3일동안 공부하며, 그리고 대회에서 코딩테스트를 진행하는 동안 Python의 능력에 감탄하고 하나씩 찾아 배워나가는 것이 제일 즐거웠다.&lt;/p&gt;

&lt;p&gt;또한 오히려 유형에 대한 준비가 안되어있었기 때문에 한 문제 한 문제 풀어나갈 때마다 희열을 느꼈다.&lt;/p&gt;

&lt;p&gt;하지만 많이 부족하다는 것도 동시에 느꼈다. 내가 나아가야할 길이 얼마나 남았는지 알 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;조금 더 정확하게, 조금 더 간결하게, 조금 더 빠르게&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;더 많은 유형을 풀어보며 업그레이드 해야겠다고 생각했다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;--다음-계획&quot;&gt;- 다음 계획&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;4월 2일에 프로그래머스에서 열리는 DevMatching이 있다.&lt;/p&gt;

&lt;p&gt;이번에도 마음은 가볍게 가져갈 생각이지만, 준비만큼은 조금 더 확실하게 하려고 한다.&lt;/p&gt;

&lt;p&gt;코딩테스트가 될 수도 있고, 과제테스트가 될 수도 있다고 하던데 어느 쪽이던지 우선 신청을 하고 소식을 받아보면서 준비해 나갈 계획이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;어쩌면 졸업을 했기에 이렇게 경험을 할 수 있는 것 이었을지도.&lt;/p&gt;

&lt;p&gt;이것이 나에게 계획된 시간표이기 때문에 지금부터 전력을 다 하면 되는 것이다.&lt;/p&gt;
</description>
        <pubDate>Tue, 23 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2021/03/23/SCOFE2021-Review/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/23/SCOFE2021-Review/</guid>
        
        
        <category>Planning And Reviewing</category>
        
      </item>
    
      <item>
        <title>Cpu Stress Test -2</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;목차&quot;&gt;목차&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Artillery 설치&lt;/li&gt;
	&lt;li&gt;Artillery를 사용해서 CPU Stress Test&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;artillery-설치&quot;&gt;Artillery 설치&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;오늘은 Artillery를 사용해서 우리가 만든 웹서버가 얼마나 많은 트래픽을 소화해낼 수 있는지 테스트해보았다.&lt;/p&gt;

&lt;p&gt;내가 수많은 테스트 툴 중에서 Artillery를 선택한 이유는 다음 두 가지이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Http, websocket 프로토콜 지원&lt;/li&gt;
  &lt;li&gt;시각화가 잘 되어 있어 한눈에 보기 편한 리포트 페이지 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;특히 리포트 페이지는 처음 열어보았을 때 너무 깔끔해서 놀랐을 정도.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://artillery.io/docs/guides/overview/why-artillery.html&quot;&gt;더 자세한 Artillery에 대한 정보&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;구글 번역을 이용할 경우 artillery가 “포병”으로 해석되서 나오니 주의.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;node.js , npm 설치&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Artillery를 설치하기 위해서는 node.js와 npm이 필수이다. 각각 아래의 명령어를 입력해서 설치.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	sudo apt install npm
	sudo apt install nodejs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Artillery 설치&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다음으로 &lt;a href=&quot;https://artillery.io/docs/guides/getting-started/installing-artillery.html&quot;&gt;Artillery 공식 문서&lt;/a&gt; 를 참조하여 Artillery를 설치하자.&lt;/p&gt;

&lt;p&gt;공식 문서에서는 -g (전역 설치) 옵션과 함께 1.6 버전을 설치하지만 나는 조금 다르게 설치하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	sudo npm install -D artillery@latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로세스가 끝나면 설치가 완료되었는지 artillery dino 명령을 사용해서 확인하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/danhdvla9/image/upload/v1615614778/ScreenShots/21-03-13/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2021-03-13_14-03-01_nyfkpd.png&quot; alt=&quot;귀여운 공룡&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;artillery를-사용해서-cpu-stress-test&quot;&gt;Artillery를 사용해서 CPU Stress Test&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;지금부터는 Artillery를 본격적으로 사용하기 위해 VSCode를 사용하였다.&lt;/p&gt;

&lt;p&gt;우선 open folder로 artillery 관련 산출물을 관리하기 위한 디렉토리를 하나 생성.&lt;/p&gt;

&lt;p&gt;new file로 어떻게 테스트를 진행할지 구성하는 artillery-cpu-test.yaml 파일을 생성.&lt;/p&gt;

&lt;p&gt;다음으로 &lt;a href=&quot;https://artillery.io/docs/guides/getting-started/installing-artillery.html&quot;&gt;Artillery 공식 문서&lt;/a&gt; 에서 core-concept 탭에 가서 맨 아래있는 기본 yaml 템플릿을 전부 복사 후 artillery-cpu-test.yaml에 붙여넣기 하고, 약간의 수정을 거쳤다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/danhdvla9/image/upload/v1615614780/ScreenShots/21-03-13/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2021-03-13_14-25-53_plikpn.png&quot; alt=&quot;yaml 파일&quot; /&gt;&lt;/p&gt;

&lt;p&gt;수정 한 이유는 hash/{input} api를 통해 get 명령만 사용할 것 이므로 나머지는 전부 날렸다. (물론 중요한 두 부분은 빼고)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;address : 웹 서버 주소 (클라우드 외부 IP)&lt;/li&gt;
  &lt;li&gt;durability : 지속시간&lt;/li&gt;
  &lt;li&gt;?? : 지속시간동안 1초마다 트래픽 증가 수치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;준비가 끝났으니 웹 서버를 켜주고, 아래 명령을 입력하여 테스트를 시작하자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	artillery run --output report.json artillery-cpu-test.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/danhdvla9/image/upload/v1615614781/ScreenShots/21-03-13/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2021-03-13_14-27-18_u0r4ft.png&quot; alt=&quot;테스트 중...&quot; /&gt;&lt;/p&gt;

&lt;p&gt;테스트가 끝나고나면 왼쪽에 지정해준 이름대로 json 파일이 생성된다. 나는 report.json으로 했으니 테스트가 잘 끝났음을 보여준다.&lt;/p&gt;

&lt;p&gt;하지만 json 파일 만으로는 테스트가 어땠는지 파악하기 어려우니 아래 명령어를 입력해서 리포트 페이지를 열었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	artillery report report.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/danhdvla9/image/upload/v1615614782/ScreenShots/21-03-13/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2021-03-13_14-27-55_hpzhuh.png&quot; alt=&quot;리포트페이지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이와같이 깔끔하게 테스트 결과를 시각화해준다. 보아하니 서버가 그냥저냥 거뜬히 견딜 정도의 트래픽이었나보다.&lt;/p&gt;

&lt;p&gt;여기서 특히 P95의 수치에 집중하였다. 서버의 비용과 유저의 만족도 간 최고의 효율을 낼 수 있는 비율이 95%라고 한다.&lt;/p&gt;

&lt;p&gt;다음은 서버가 적당히 스트레스를 받을 정도의 부하를 줘 보자. 트래픽을 초당 15로 수정 후 report-15.json으로 다시 진행하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/danhdvla9/image/upload/v1615614783/ScreenShots/21-03-13/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2021-03-13_14-36-32_qc0cfs.png&quot; alt=&quot;리포트페이지-15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;900 정도의 트래픽이 몰리니 에러도 나오고 지연 시간이 꽤 오래 걸리기 시작했다. 거의 마지막에는 1만 ms 를 넘겼는데 이는 대충 10초가 지나야 응답이 온다는 뜻이다. 내 입장에선 10 초 정도면 나름 견딜만 한 시간인데 전체 유저 입장에서 보면 적당한 것 일까 하는 의문이 든다.&lt;/p&gt;

&lt;p&gt;비용이 많다면 유저를 만족시키는 정확한 성능을 찾는 것이 중요하겠지만, 비용이 제한된 상황에서라면 어떤 지침을 따르는 것이 맞을지 찾아보았는데 다음 세 가지를 만족하는 방향을 찾으면 된다고 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예상 TPS보다 여유롭게. 예상 3000이라면 적어도 4000이상&lt;/li&gt;
  &lt;li&gt;기대 Latency를 만족할 때 까지&lt;/li&gt;
  &lt;li&gt;Scale-out을 해도 성능이 높아지지 않는다면 병목을 의심&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이상으로 CPU Stress Test 포스팅을 마무리한다. 처음해본 배포, 처음해본 부하 테스트 였는데 작지만 내가 만든 애플리케이션이 클라우드를 통해 배포되고, 많은 트래픽이 오는 상황을 예측해볼 수 있다니 두근거리는 경험이었다. 후에 이 경험을 살려 실제로 내가 회사나 개인 프로젝트를 띄워서 관리 중일 때 얼마나 많은 트래픽을 견뎌낼 수 있을지 테스트할 수 있을 것 같다.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2021/03/15/Cpu-Stress-Test-2/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/15/Cpu-Stress-Test-2/</guid>
        
        
        <category>Back-End-Study</category>
        
      </item>
    
      <item>
        <title>KT Cloud TroubleShooting (ubuntu account)</title>
        <description>&lt;h3 id=&quot;리눅스-os-ubuntu에서-kt-cloud-instance-os-ubuntu-ssh-접속-문제&quot;&gt;리눅스 OS (ubuntu)에서 KT Cloud Instance OS (ubuntu) ssh 접속 문제&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Description&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;KT Cloud의 D1을 이용하다가, 사용 중인 노트북의 os가 ubuntu였기 때문에 시작된 문제이다. ssh 접속 시 openssh의 버전에 따라 client에서의 접속이 차단 될 수 있다는 점을 새로 알게되었고, KT Cloud 기술 문서에서 오점을 찾아내었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Error Code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ubuntu에서 ssh 명령어로 원격 접속하려 했으나 Connection Closed 됨.&lt;/p&gt;

&lt;p&gt;Windows에서 putty를 이용해 접속하려 했으나 not existing current key 출력 됨.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TroubleShooting&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Connection Closed가 되었다는건 연결은 되나 무언가의 오류로 인해 연결을 막고 있다는 뜻으로 해석했다.&lt;/p&gt;

&lt;p&gt;그리고 언제나 나를 괴롭혀왔던 버전문제… 이번에도 역시나였다. (&lt;del&gt;운이 좋았다. 헤헤&lt;/del&gt;)&lt;/p&gt;

&lt;p&gt;client와 server의 버전이 다를 경우 ssh 접속이 차단되는지 구글링을 시작하였고, 얻어낸 답은&lt;/p&gt;

&lt;p&gt;ssh는 client의 버전이 server 버전보다 높을 경우 Connection Closed로 접속을 차단한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그래서 Windows로 먼저 접속해서 openssh의 버전을 update하고 다시 ubuntu로 시도해보기로 했다.&lt;/p&gt;

&lt;p&gt;그런데 Windows로 접속 시도 중 예상치 못하게 키페어가 없다는 오류가 뜨면서 막막해지기 시작했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/danhdvla9/image/upload/v1615814654/ScreenShots/21-03-05/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2021-03-15_22-12-33_ranxex.png&quot; alt=&quot;KT Cloud User Guide&quot; title=&quot;너 때문이야&quot; /&gt;&lt;/p&gt;

&lt;p&gt;공식 기술 문서를 다시 읽어보고 여러번 시도해보고 실패하고 반복하던 도중, 기술 문서에는 ubuntu os 는 계정명을 ubuntu으로 사용하라는 문장을 발견.&lt;/p&gt;

&lt;p&gt;설마… 하는 느낌이 와서 계정을 ubuntu가 아닌 root로 바꿔보았다. CentOS는 root 로그인이 가능한데 ubuntu는 따로 언급이 없다는 것이 흠칫했다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;접속에 성공했다…..&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;허무했다. 하지만 기술 문서에서 보완할 점을 하나 찾았다는 것이 꽤 뿌듯했다. 앞으로 클라우드 서버를 자주 이용하게 될테니 신고식 한 번한 셈 쳐야겠다.&lt;/p&gt;

</description>
        <pubDate>Fri, 05 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2021/03/05/KT-Cloud-TroubleShooting/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/05/KT-Cloud-TroubleShooting/</guid>
        
        
        <category>TroubleShooting</category>
        
      </item>
    
      <item>
        <title>Cpu Stress Test -1</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;목차&quot;&gt;목차&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;I/O Burst, I/O Bound VS CPU Burst, CPU Bound&lt;/li&gt;
	&lt;li&gt;Hash를 이용해서 CPU를 극단적으로 사용하기 (feat. Spring Boot)&lt;/li&gt;
	&lt;li&gt;GCP 인스턴스에 배포&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;io-burst-io-bound-vs-cpu-burst-cpu-bound&quot;&gt;I/O Burst, I/O Bound VS Cpu Burst, Cpu Bound&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;I/O Burst와 I/O Bound는 무엇이고, Cpu Burst와 Cpu Bound는 무엇일까?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이를 설명하기 위해서는 우선 프로세스가 처리되는 과정을 먼저 알아야한다.
그 전에 프로그램과 프로세스의 차이점부터 짚고 넘어가자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로그램&lt;/strong&gt; : 하드에 저장되어 있는 Application &lt;br /&gt;
&lt;strong&gt;프로세스&lt;/strong&gt; : 메모리에 적재되어 있는 프로그램&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 메모리에 적재되어 처리를 기다리고 있는 프로세스들을 처리하는 순서를 &lt;strong&gt;프로세스 스케줄링&lt;/strong&gt;이라 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 프로세스 스케줄링에 따라 프로세스들은 CPU에 의해 처리되는데, 이 때 CPU에 I/O(input/output)되는 시간을 &lt;strong&gt;I/O Burst&lt;/strong&gt;, CPU가 프로세스를 처리하는 시간을 &lt;strong&gt;CPU Burst&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그리고 I/O Burst가 큰 프로그램을 &lt;strong&gt;I/O Bound&lt;/strong&gt;, CPU Burst가 큰 프로그램을 &lt;strong&gt;CPU Bound&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;나는 GCP CPU 테스트를 위해 CPU Burst가 높은 간단한 프로그램을 만들었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;hash를-이용해서-cpu를-극단적으로-사용하기&quot;&gt;Hash를 이용해서 CPU를 극단적으로 사용하기&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;아래와 같은 코드를 참조하여 hash (md5)를 이용하는 프로그램을 작성하였다.&lt;/p&gt;

&lt;p&gt;hash가 무엇인지 궁금하다면?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@yeon22/crypto-%ED%95%B4%EC%8B%9C-hash-%EB%9E%80-6962be197523&quot;&gt;해시에 대해&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;’'’java
	import org.springframework.web.bind.annotation.PathVariable;
	import org.springframework.web.bind.annotation.RequestMapping;
	import org.springframework.web.bind.annotation.RestController;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import javax.xml.bind.DatatypeConverter;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

@RestController
public class HashController {

	@RequestMapping(&quot;/hash/{input}&quot;)
	public String getDigest(@PathVariable(&quot;input&quot;) String input) throws NoSuchAlgorithmException {
	    for(int i = 0; i &amp;lt; 100_000; i++) {
	        input = getMD5Digest(input);
	    }
	    return input;
	}

	@RequestMapping(&quot;/hello&quot;)
	public String hello() {
	    return &quot;hello&quot;;
	}

	private String getMD5Digest(String input) throws NoSuchAlgorithmException {
	    MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
	    md.update(input.getBytes());
	    byte[] digest = md.digest();
	    String myHash = DatatypeConverter
	            .printHexBinary(digest).toUpperCase();

	    return myHash;
	}
} '''
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;참조 : https://github.com/lleellee0/cpu-bound-application &lt;br /&gt;
–추가사항 : 충돌 방지를 위해 application.properties 파일에서 server.port 를 80으로 설정해줘야 한다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;/hash/{input} 과 /hello 두 가지 매핑이 있고, input에 들어온 문자열을 10만번 해시 연산한 결과를 반환한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ERROR FIX&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;JDK8이 아닌 다른 버전을 쓸 경우 DataTypeConverter를 찾지 못하는 오류가 있었다.&lt;/p&gt;

&lt;p&gt;나는 11로 하고 있었기 때문에 해당 패키지가 제외되어있던 상태라 의존성을 추가해주어야 했다.&lt;/p&gt;

&lt;p&gt;’'’xml
	&lt;dependency&gt;
		&lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
		&lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
		&lt;version&gt;2.3.1&lt;/version&gt;
	&lt;/dependency&gt;
‘’’&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;gcp-인스턴스에-배포&quot;&gt;GCP 인스턴스에 배포&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;1 intelliJ 우측에서 maven 탭을 통해 .jar 파일을 만든다. (Maven -&amp;gt; Lifecycle -&amp;gt; deploy 더블클릭으로 생성!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;익숙했던 maven 이지만 처음 알았던 내용인 만큼 조금 충격이었달까…
그동안 배포를 한번도 안해봐서 .jar 파일을 만들 생각도, 만들어 볼 못했지만 
이렇게해서 배포가 이루어 진다는 것을 배웠을 때 굉장히 희열을 느꼈다.
( &lt;del&gt;생각해보니까 패키지 매니저인데 의존성 관리만 하고 패키징을 제대로 해본 적이 없었네…&lt;/del&gt; )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2 깃허브 Repo에 push.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;3 GCP 인스턴스에 가서 wget [repo에 저장된 .jar파일 주소]을 사용해 인스턴스에 다운로드.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;나는 CentOS를 설치했기 때문에 yum install wget을 통해 wget 설치하였다. &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;GCP 는 한 계정당 3달간 300달러 무료 크레딧을 지급한다. 초과 시 과금되니 계정관리 필수 !! &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;GCP 인스턴스 생성에 대해서는 생략한다. &lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;4 sudo java -jar [다운받은 .jar 파일명] 명령어를 통해 실행 테스트!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://res.cloudinary.com/danhdvla9/image/upload/v1614939147/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2021-03-05_19-07-13_m3hhzt.png&quot; alt=&quot;GCP instance&quot; title=&quot;구동테스트&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정상적으로 실행되는 모습이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;스트레스 테스트를 위한 과정 중 중간까지 왔다. 이제 준비가 다 되었고 스트레스 테스트하는 일만 남았는데 준비하는 과정만해도 새로이 배우는 것들이 많아서 굉장히 재미있었다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음 포스팅에서는 스트레스 테스트 툴 중 하나인 Artillery를 이용하여 테스트 결과를 출력해보자.&lt;/p&gt;
</description>
        <pubDate>Wed, 03 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2021/03/03/Cpu-Stress-Test/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/03/Cpu-Stress-Test/</guid>
        
        
        <category>Back-End-Study</category>
        
      </item>
    
      <item>
        <title>About me</title>
        <description>&lt;center&gt;
&lt;img id=&quot;se_object_16146119104829970&quot; src=&quot;https://res.cloudinary.com/danhdvla9/image/upload/v1615614668/Thumbnails/profile_ogfa9f.jpg&quot; alt=&quot;profile&quot; title=&quot;It's me&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;about-me&quot;&gt;About me&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이름 : 이장훈 (HEPHAI)
&lt;br /&gt;
생일 : 1996 / 10 / 31
&lt;br /&gt;
주소 : 경기도 화성시
&lt;br /&gt;
&lt;br /&gt;
관심 분야 :&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;BackEnd&lt;/li&gt;
	&lt;li&gt;Cloud&lt;/li&gt;
	&lt;li&gt;Blockchain&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;취미 :&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;캠핑&lt;/li&gt;
	&lt;li&gt;낚시&lt;/li&gt;
	&lt;li&gt;요리&lt;/li&gt;
	&lt;li&gt;운동 (PT, 축구)&lt;/li&gt;
	&lt;li&gt;영상 편집&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Strong Point : 언제나 전체의 입장이 되어서 가장 올바른 해답을 찾으려 노력함.&lt;/p&gt;

&lt;p&gt;Weak Point : 한 가지 일에 너무 심취할 경우 다른 일을 잘 보지 못함.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;who-am-i&quot;&gt;Who am I?&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;소프트웨어전공 4년 2학기가 되서야 개발의 재미를 깨닫기 시작한 주니어 프로그래머. &lt;br /&gt;
CapStone Project로 Android App 개발 도중, Google Firebase를 이용하다가 BackEnd에 관심을 가지기 시작하였다. &lt;br /&gt;
이후 Spring boot / Docker / K8s / Node.js / Hyperledger fabric 등을 공부하고 있다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;개발을 매우 잘하는 개발자도 되고 싶지만, 그보다는 어떠한 팀에도 어울리는 “물” 같은 개발자가 되고 싶다. &lt;br /&gt;
어떤 팀에도 잘 섞여들고, 어떤 정보도 잘 녹이고, 어떤 사람들에게나 친근하고 꼭 필요한 개발자가 되는 것이 목표이다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;개발은 “불”같은 열정으로, 협업은 “물”같은 유연함으로. &lt;br /&gt; 
불과 물을 이용해 최고의 명작을 만들어내는 대장장이와 같이 개발하는 것이 내가 추구하는 개발자의 이미지이다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;education&quot;&gt;Education&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;2012 ~ 2014  부광고등학교&lt;/li&gt;
	&lt;li&gt;2015 ~ 2021  공주대학교 소프트웨어전공&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;※ 2016 ~ 2018 공군 만기 전역&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;experience-ing&quot;&gt;Experience (~ing)&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;공주대학교 소프트웨어전공 졸업&lt;/li&gt;
	&lt;li&gt;&quot;쉽게 배우는 소프트웨어 공학 - 김치수 저&quot; Design Pattern 파트 예시코드 작성 및 집필 도움.&lt;/li&gt;
	&lt;li&gt;&quot;JARA-DreamFairy&quot; 수면 패턴 유도 Android Application 개발 경험&lt;/li&gt;
	&lt;li&gt;&quot;Ziktalk&quot; 엠버서더 및 테스터 활동&lt;/li&gt;
	&lt;li&gt;Youtube Channel &quot;따배런&quot; 기획도움 및 편집자&lt;/li&gt;
	&lt;li&gt;한국 소비자원 &quot;컨텐츠 크리에이팅 공모전&quot; 입상 (1등 최우수상)&lt;/li&gt;
	&lt;li&gt;고등, 대학생 대상 IT Internship 부팀장으로 &quot;지식 나눔 활동&quot;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;certificate&quot;&gt;Certificate&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;정보처리기사&lt;/li&gt;
	&lt;li&gt;JLPT N1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;familiar-skills&quot;&gt;Familiar Skills&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;C, python, R, java, spring, docker, k8s, (node.js) 추후 이미지로 변경.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;contact&quot;&gt;Contact&lt;/h4&gt;

&lt;ul&gt; 
	&lt;li&gt;E-mail : icetime963@gmail.com&lt;/li&gt;
	&lt;li&gt;Github : bingsu-kun@github.com&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 01 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2021/03/01/about-me/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/01/about-me/</guid>
        
        
        <category>Hephai</category>
        
      </item>
    
  </channel>
</rss>
